# Продвинутая математика

Ответы:  
1) Переполнение int i1  
2) Переполнение значения в скобочках (i1+i2)  
3) Всё супер, ничего не переполняется!  

## Содержание 

[**Переполнение типов**](#переполнение-типов)

[**Решето Эратосфена**](#решето-эратосфена)

[**Модульная математика**](#модульная-математика)

[**Бинарное возведение в степень**](#бинарное-возведение-в-степень)

[**Обратное по модулю**](#обратное-по-модулю)

[**Предподсчёты**](#предподсчёты)

## Переполнение типов

max_int = 2\*1e9  
max_long_long = 9\*1e18

Соответственно нельзя записывать в переменные соответствующих типов числа большие чем максимальные значения. Но есть в переполнении типов некоторые нюансы.

Пусть:  
int i1 = ~max_int  
int i2 = ~max_int  
long long L = ~max_int  

Что будет происходить в следующих случаях? *Ответы в начале статьи.*  
1) `i1 = i1+i2`  
2) `i1 = (i1+i2)%100`  
3) `i1 = (i1+L)%100`  

Вариант номер 3 - оптимальный, потому что ничего не переполняется, а значит нам это нравится:)

**Вывод:** Если вам нужно взять что-нибудь по модулю(и чтобы ничего не переполнилось) одна из переменных в скобочках должна быть long long.

Пользуйтесь этим выводом на протяжении всей лекции.

## Решето Эратосфена

Цель: найти все простые числа в промежутке [2, N].

### Тривиальная идея

Сперва будем счиать, что все числа простые(кроме 1).
Затем последоавтельно(начиная с 2) будем обрабатывать числа:
1) Если p - простое => k * p - составное, для k > 1.
2) Если p - составное, то ничего не делаем.
Корректность очевидна.

### Тривиальная реализация

```c++
int N;
std::vector<bool> is_prime(N + 1, true);
for (int i = 2; i <= N; i++) {
    if (is_prime[i]) {
        std::cout << i;
    } else {
        for (int j = 2 * i; j <= N; j += i) {
            is_prime[j] = false;
        }
    }  
}
```

### Асимптотика

Теорема(б/д).
f(n) = Sum\[p<=n\](1/p) = ln(ln(n)) + M + O(1/ln(n)),\
M ~= 0.261

Откуда наше решение имеет асимптотику:

Sum\[p <= n, p - prime\](n / p) = O(n * ln(ln(n)))

На практике, это почти O(n). Даже при $n = 10^9$: $ln(ln(n)) ~= 3$. 

### Можно лучше!

Предложу реализацию за O(n).

```c++
vector<int> primes;
min_d[2..n] = {2, ..., n}

for (int k = 2; k <= n; k++) {
    if (min_d[k] == k) primes.pb(k);
    for (auto p : primes) {
        if (p * k > n or p > min_d[k]) {
            break;
        }
        min_d[p * k] = p;
    }
}
```

### Пояснение

Новое решение находит min_d[k] - минимальный делитель чисел $k \in \[2 \dots n\]$.

Тогда критерий простоты min_d\[k\] == k.

Асимптотика O(n) обусловлена тем, что каждый min_d мы обновялем ровно 1 раз.

## Модульная математика

Иногда программистам приходится работать с большими числами, но большие числа не всегда влезают в типы данных int и даже long long.

Составители задач это понимают и в случаях работы с большими числами просят вывести ответ по модулю числа m. *В основном m = 10^9+7 или 10^9+9*  
Это означает что вам нужно вывести остаток от деления ans на m, или, другими словами, ans%m

Когда встаёт задача вывести ответ по модулю m, можно пользоваться следующей идеей:

Мы будем брать остаток по модулю m не в самом конце задачи так: `cout<<ans%m` 
 
А будем брать остаток по модулю m на каждом шаге формирования значения ans, например:
- Прибавили что-нибудь к ans? Пишем сразу: `ans = (ans + val)%m`
- Умножили ans на что-нибудь? Пишем сразу: `ans = (ans*val)%m` 
- Вычли что-нибудь из ans? Пишем сразу: `ans = (ans - val)%m`, *На самом деле не совсем так, но об этом позже.*

Зачем это делается? Чтобы избежать переполнения типов int и long long.

Потому что если сразу сложить `ans = (val1 + val2 + val3)%m`, то выражение в скобочках может переполниться, а если сделать так, то всё будет хорошо:
```c++
ans = (ans + val1)%m;
ans = (ans + val2)%m;
ans = (ans + val3)%m;
```

### Сложение по модулю 

Складывать по модулю можно так: `ans = (ans + val)%m`

### Вычитание по модулю

Вычитать по модулю можно. Однако есть нюанс. Когда мы вычитаем из одного положительного числа другое положительное число, то ответ может получиться отрицательным:
Пусть ans = 3 и val = 4.

И если например:
`ans = (ans-val)%2;`, тогда подмодульное выражение ans - val = 3 - 4 = -1, тогда ans = (-1)%2 = -1, что нас не устраивает. Нам нужно положительное значение ans на каждом этапе его формирования.  
Поэтому **пользуемся следующим трюком**: `ans = ((ans - val)%m + m)%m`

### Умножение по модулю

Умножать по модулю можно так: `ans = (ans*val)%m`

### Деление по модулю

Делить по модулю нельзя:(

### Послесловие

Очень сильно контролируйте, чтобы в задаче, где фигурируют большие числа, никакой тип данных не переполнился. Берите по модулю сразу и не забывайте про ловушку вычитания.

## Бинарное возведение в степень

Всем вам известно, что a^b = a\*a....\*a\*a, где множителей b штук.

И вдруг программисту понадобилось решить задачу: "Найдите a^b, где b - очень большое число, например 10^9". *В такой задаче в основном просят найти (a^b)%m, потому что a^b чаще всего не влезает ни в int, ни в long long* 

Очевидное решение приходит в голову: *Давайте просто умножим b раз a*. Ассимптотика такого решения O(b)

Однако есть решение (ака. Бинарное возведение в степень) за O(log b). Оно предполагает рекурсию.

Представим, что b - чётное. Тогда мы можем найти t = a^(b/2), а затем возвести в квадрат: return t^2; *Подумать только! Мы уменьшили задачу в два раза! Отсюда и появляется Log b:)*

Представим, что b - нечётное. Тогда мы можем найти t = a^(b-1), а затем умножить на a: return (a^(b-1))\*a; *b-1 то точно будет чётным, а для него мы знаем как уменьшить задачу в два раза)*

База: Если b = 0, То a^b = a^0 = 1, независимо от a.

Отсюда решение рекурсией:

```c++
int mod = 1e9 + 7;

int bp(long long a, int b){
	if(b==0) return 1;
	if(b%2==0){
		long long t = bp(a,b/2)
		return (t*t)%mod;
	}else{
		reutrn (bp(a,b-1)*a)%mod;
	}
}
```

Вы можете заметить как тщательно автор выбирает типы данных для переменных. В каждой скобочке есть переменная типа long long, чтобы умножение не переполнило тип int.

P.S. Альтернативой таких приколов может быть использование "фиктивных" чисел `0ll` и `1ll`.

Например, пусть int a = b = ~max_int;  
`int c = (0ll + a + b)%m` и  
`int d = (1ll*a*b)%m` - не переполняется!

## Обратное по модулю

**Warning: далее будет математика.**

В математике есть такая Малая Теорема Ферма(МТФ). Выглядит она так: `a^(m-1) % m =  1`, где m - простое число. Читайте в интернете подробнее.

А в информатике есть такая задача: "найдите обратное числу a по простому модулю m". И решается она с помощью МТФ.

Что такое обратное по модулю, спросите вы? Пусть есть число a и простой модуль m. Тогда b - обратное по модулю, если a\*b % m = 1.

Заметим, что если b = a^(m-2), то a\*b = a\*a^(m-2) = a^(m-1). В свою очередь a^(m-1) % m = 1, что нам и нужно.

Т.е. **b = a^(m-2) и есть обратное по простому модулю m для числа a**! Исходя из свойств модулей `b = a^(m-2) % m` тоже подходит;) 

Однако чтобы получить такое число b, нам нужно [бинарное возведение](#бинарное-возведение-в-степень). Создадим функцию, где и воспользуемся им!

```c++
int obr(int a, int m){
	reutrn bp(a,m-2);
}
```

### Для чего это нужно?

Вообще составители задач иногда напрямую просят в качестве ответа вместо a вывести obr(a,mod), где mod - данное в условии простое число. Хотя бы поэтому стоит знать этот алгоритм.

А ещё, a/b % mod = a\*obr(b) % mod, т.е. операция взятия обратного по модулю заменяет деление по модулю, но об этом позже) 

## Предподсчёты

Предподсчёт - общая идея в программировании, когда вы в начале программы пишете код, который считает некоторые значения и записывает их в какой-нибудь глобальный массив или другую структуру. Вы же потом в программе пользуетесь числами из этого массива, просто беря их оттуда за небольшую ассимптотику.

Можно предподсчитать(найти) все простые числа меньшие 10000, а можно предподсчитать степени тройки в начале программы. Предподсчёты бывают разные.

### Упражнение

Задание: напишите предподсчёт всех простых чисел меньших 10000 и закиньте их в set.

Ответ:
```c++
bool prime(int n){
	for(int i = 2; i*i<=n; i++){
		if(n%i==0) return false;
	}
	return true;
}

int main(){
	set<int> s;
	for(int i = 2; i < 10000; i++){
		if(prime(i)) s.insert(i);
	}
}

```

### Предподсчёт факториалов для C(n,k)

*Факультативно*

[Читайте emaxx, там подробно о свойствах биноминальных коэф.](https://e-maxx.ru/algo/binomial_coeff)

Факториал обозначается знаком "!",  
n! = 1\*2\*3...\*(n-1)\*n

C(n,k) - Количество различных способов выбрать из n элементов подмножество из k элементов.  
С(n,k) = n!/(k! \* (n-k)!)

С(n,k) иногда нужно для задач на комбинаторику, т.е. для таких задач, где нужно посчитать количество способов чего-нибудь.

Как вы можете видеть, нам для поиска C(n,k) нужны факториалы. Предподсчитаем же их! *Задача поиска C(n,k) также как и возведения в степень решается обычно по модулю m, т.к. числа опять-таки большие.*

Как сказано [здесь](#для-чего-это-нужно), обратное по модулю заменяет деление, поэтому вместо того, чтобы делить на fac\[k\] и fac\[n-k\], можно умножить на obr(fac\[k\]) и obr(fac\[n-k\]); Поэтому кстати предподсчитаем и обратные факториалы.

Код:

```c++
int mod = 1e9+7;
const int maxn = 1e5;
int fac[maxn+1];
int ofac[maxn+1];

int C(int n, int k){
	return (((fac[n]*ofac[k])%mod)*ofac[n-k])%mod;
}

int main(){
	fac[1] = 1;
	for(int i = 2; i <= maxn; i++){
		fac[i] = (fac[i-1]*i)%mod;
	}
	
	ofac[maxn] = obr(fac[maxn]);
	for(int i = maxn-1; i>=1; i--){
		ofac[i] = (ofac[i+1]*(i+1))%mod;
	}

}
```

Первый блок кода в main-е понятен: он предподсчитывает факториалы.

Чтобы предподсчитать обратные факториалы, воспользуемся небольшим трюком: будем считать их с конца.  
База: `ofac[maxn] = obr(fac[maxn]);`
А чтобы посчитать ofac\[i\], заметим, что достаточно просто умножить ofac\[i+1\]\*(i+1), ведь ofac\[i+1\]\*(i+1) = (i+1)/(1\*2...\*i\*(i+1)) = 1/(1\*2...\*i) = ofac\[i\].
___

## [Sigma Omsk](https://vk.com/sigma_omsk) 2020
