# Два указателя

## Мотивация

К примеру - нам нужно сделать q lower_bound-ов на векторе v по значениям $\{value_1, ..., value_q\}$, притом вектор v и $values$ отсортирован.
Тривиально - запустить std::lower_bound и получить асимптотику O(q * log(n)).
Мы никак не использовали то что values отсортированы, поэтому есть предположение, что можно лучше. Мы как бы решаем задачу по кусочкам и не смотрим на структуру целиком.

Эту проблему решают два указателя - тогда мы смотрим на картину целиком, это помогает улучшить асимптотику, в частности в этой задаче достичь O(n + q).

## Идея

Общая идея, как может стать понятно из названия, в поддержании двух указателей и подсчёте какой-то статистики после каждого их передвижения. 

Это не какой-то конкретный алгоритм - скорее общая идея решения задач.

Часто два указателя работают на отсортированном массиве или массиве с некоторыми дополнительными условиями.

## Реализация

В случае (самом частом), когда указатели двигаются одновременно вперед, код выглядит примерно так:

```c++
int ptrL = 0, ptrR = 0;
for (; ptrL < n; ptrL++) {
    while (ptrR < n && condition(ptrL, ptrR)) {
        ptrR++;
    }
    // В этот момент мы достигли оптимального решения, можно посчитать что-то.
    do_smth(ptrL, ptrR);
}
```

То есть мы поддерживаем указатель ptrL - как начало рассматриваемого отрезка, ptrR - как первый элемент после рассматриваемого отрезка.

condition(ptrL, ptrR) - провервяет, подходит ли отрезок [ptrL, ptrR] по логике.

do_smth(ptrL, ptrR) - совершает какую-ту работу.

## Асимптотика

Линейная, относительно передвижения указателей: ptrL будет передвинут ровно n раз; ptrR - примерно тоже самое. В свою очередь condition() и do_smth() могут внести множители к нашему O(n), хотя чаще всего их возможно делать за O(1), так что асимптотика должна остаться линейной.

## Пример

Задача: дан массив неотрицательных целых чисел. Найти отрезок с максимальной суммой, не превышающей C.

Упражнение: предложите решение этой задачи с бинпоиском и префикс-суммами за O(n log(n))

Мысли: да, можно было бы предподсчитать префикс-суммы, затем перебрать начало отрезка и для каждого начала бинпоиском найти конец отрезка. Мы опять посмотрели на задачу по кусочкам и получили сверх-линейную асимптотику.

**Решение двумя указателями:**

```c++
int n;
std::vector<int> v(n);
int C;

int ptrL = 0, ptrR = 0;
int sum = 0;
int opt_sum = -1;
int opt_L = -1, optR = -1;
for (; ptrL < n; ptrL++) {
    while (ptrR < n && sum + v[ptrR] < C) {
        sum += v[ptrR];
        ptrR++;
    }
    if (sum > opt_sum) {
        opt_sum = sum;
        opt_L = ptrL, opt_R = ptrR;
    }
    sum -= v[ptrL];
}

cout << opt_L << " " << opt_R;

```

Как видите, мы поддерживаем нынешний полуинтервал и сумму на нём: `ptrL, ptrR, sum`; оптимальный полуинтервал и заодно сумму на нём: `opt_L, opt_R, opt_sum`. Асимптотика - линейная.

## Ещё пример: merge

Имеем два отсортированных массива, хотим получить один большой отсортированный массив, в котором будут элементы из тех двух. Для того чтобы не просто std::sort-ить массив объединения за O(nlog(n)), мы выполним процедуру слияния (merge) за O(n).

```c++
int n, m;
std::vector<int> a(n), b(m);
std::vector<int> c(n + m);
int ptrA=0, ptrB=0;

INF = 2e9 + 100;
a.push_back(INF);
c.push_back(0);

for (int ptrA = 0; ptrA < a.size(); ptrA++) {
    while (ptrB < b.size() && b[ptrB] < a[ptrA]) {
        c[ptrA + ptrB] = b[ptrB];
        ptrB++;
    }
    c[ptrA + ptrB] = a[ptrA];
}

c.pop_back();
```

Как вы можете заметить, шаблон вновь похож - for-ом двигаем один указатель, while-ом внутри - второй. 

## Разбор задачи из Мотивации

```c++
int n, q;
std::vector<int> values(q);
std::vector<int> ans(q, n); // Сюда положим индексы v.lower_bound(values[i]) - v.begin()
std::vector<int> v(n);

int val_ptr = 0;
for (int ptr = 0; ptr < n; ptr++) {
    while (val_ptr < q && values[val_ptr] <= v[ptr]) {
        ans[val_ptr] = ptr;
        val_ptr++;
    }
}

// оставшиеся элементы $ans$ по умолчанию заполнены значением $n$

```

## Замечание

Есть один неприятный сайд-эффект двух указателей: в конце указатель ptr_other (тот который двигаем while-ом) может не доделать какие-то итерации. Алгоритм его не обязывает к этому.

Существует два способа выйти из ситуации:
1) Написать дополнительный for после нашего кода, который двигает ptr_other.
2) Добавить в массив какое-то фиктивное значение, чтобы гарантировать, что ptr_other будет сдвинут. В конце надо не забыть обработать это фиктивное значение.

И если (1) вопросов не вызывает, то поясню (2). Я предпочитаю использовать его и весь код выше был написан основываясь на нём.

- **В первом примере** движение ptrR обеспечено движением ptrL. Мы точно знаем, что ptrR всегда будет не меньше ptrL. 
- **Во втором примере** мы в начале специально положили в конец вектора a большое число, которое вытащит в последнем while-е все ptrR и затем положится само. В конце мы его же достали из конца массива с ответом, потому что знаем что оно больше остальных.
- **В разборе задачи** из мотивации мы недоделанные итерации пофиксили изначально правильно заполненным ans. Т.е. для тех values[i], которые больше чем весь массив - ответ lower_bound-а - это n. Мы это и обеспечили.

___

## [Sigma Omsk](https://vk.com/sigma_omsk) 2020
