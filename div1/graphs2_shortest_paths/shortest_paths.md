# Кратчайшие пути

Кратчайшие пути в графах: Алгоритм Дейкстры. Алгоритм Форда-Беллмана и Флойда.

## Содержание

[**Мотивация**](#мотивация)

[**Случай невзвешенных графов**](#невзвешенные-графы)

[**Алгоритм Дейкстры**](#алгоритм-дейкстры)

[**Алгоритм Флойда**](#алгоритм-флойда)

[**Алгоритм Форда-Беллмана**](#алгоритм-форда-беллмана)

## Мотивация

Представим, что дан граф (ориентированный или неориентированный). Самой простой и понятной задачей может быть найти расстояние от одной вершины до другой. Пример: гугл-карты это некоторый граф, в котором часто возниакет задача поиска кратчайшего пути от точки A до B. Рассмотрим алгоритмы нахождения кратчаших путей в невзвешенных и взвешенных графах по отдельности.

## Невзвешенные графы

Будем называть невзвешнным (ориентированным или неориентированным) графом - граф, где ребра не имеют веса, а просто либо проведены, либо нет. Иными словами, самый стандарный из графов. Ранее рассмотренный алгоритм BFS позволяет решать задачу. Кратко напомним:

### BFS

В предыдущем конспекте (об алгоритмах DFS-BFS) вы уже узнали этот алгоритм. По большому счёту, запуская BFS из вершины 0, мы можем найти расстояния от вершины 0 до всех остальных вершин за $O(n + m)$, где, как и обычно: $n$ - количество вершин, $m$ - количество ребер.

### Двусторонний BFS

Предположим, что $m$ и $n$ слишком велико, однако нам необходимо найти расстояние от вершины $s$ только до вершины $f$ в невзвешенном графе. Просто запустить BFS не получится, однако для таких случаев есть модификация: двусторонний BFS. Запустим "одновременно" два BFS из двух вершин. Как только одна вершина будет посещена двумя алгоритмами - кратчайший путь будет проходить через неё, а значит длина кратчайшего пути - FirstBFS[v] + SecondBFS[v].

## Взвешенные графы

Основная часть конспекта посвящена взвешенным графам, поэтому в этой главе будем говорить только о них.

### 0-k BFS

Предположим, что веса рёбер - целые числа $\in \[0, k\]$. Имеем цель найти расстояния от вершины $s$ до всех остальных.

Упражнение: свести задачу к BFS и найти асимптотику решения.

*Замечание*: асимптотика будет O(kn + km), достигается растягиванием путя веса $x$ в $x$ последовательно соединенных путей длины 1. Однако можно быстрее, рассмотрим следующий алгоритм:

Для каждого возможного расстояния $\in \[0, k * n\]$ создадим очередь. Для каждой очереди будем запускать bfs и устанавливать `dist[v] = t` как только вершина вышла из очереди с номером t (притом заметим что вершина может оказаться в нескольких очередях, поэтому логично устанавливать `dist[v]` как только вершина в первый раз вышла из некоторой очереди). Изначально положим $s$ в очередь с номером 0.

#### Асимптотика

O(kn + m)

#### Замечание

Заметим, что k + 1 очередей достаточно.

### Алгоритм Дейкстры

Работает на положительных графах (рёбра положительной длины).

Можно думать об алгоритме, как о последовательном увеличении верной компоненты.

#### Реализация

```c++
void dijkstra(long long startV) {
    std::vector<long long> dist(mod, inf);
    dist[startV] = 0;
    std::set<std::pair<long long, int>> st = {std::make_pair(0, startV)};
    while (!st.empty()) {
        int v = st.begin()->second;
        st.erase(st.begin());
        for (int {t, w}: edges[v]) {
            if (dist[t] > dist[v] + w) {
                st.erase({dist[t], t});
                dist[t] = dist[v] + w;
                st.insert({dist[t], t});
            }
        }
    }
}
```

#### Асимптотика:

O((m + n) * log(n)) //m logn - update dist, n logn - extract min

### Алгоритм Флойда

Ищет попарные кратчайшие расстояния. Могут быть отрицательные рёбра, но нет отриц. циклов.

`dp[i][j][k]` - минимальная длина пути `i->j`, т.ч. все промежуточные вершины имеют номера <= k.

База:\
`dp[i][j][0] = cost(i, j)` или = +inf, если нет ребра

Переход:\ 
`dp[i][j][k] = min(dp[i][j][k - 1], dp[i][k][k - 1] + dp[k][j][k - 1])`

Ответ лежит:\
`dp[s][f][n]` 

#### Реализация:

Относительно наших теоретических рассуждений, просто уберем последнее измерение динамики для уменьшения используемой памяти.

Изначально: g - матрица смежн. графа, т.е. `g[i][j] = вес ребра / +inf`

```c++
for (int k = 0; k < n; k++) { // сперва перебираем промежуточную вершину.
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
        }
    }
}
```

Т.е. поочереди добавляем вершины k = 1 .. n и полагаем, что путь может проходить через них

#### Асимптотика:

$O(n^3)$ по времени и памяти

### Алгоритм Форда-Беллмана

Ищет кратчайшее расстоние от s до всех, притом в графе могут быть отрицательные циклы.

Определим: `dp[v][k]` - кратч. расстояние от s до v, при использовании <= k рёбер.

База:\
`dp[v][0] = (0 if v == s else +inf)`

Переход:\
`dp[u][k] = min(dp[u][k - 1], min{dp[v][k] + cost(v, u) | for (v, u) in edges})`

Ответы лежат(в предположении, что нет отриц. циклов):
for v: `dp[v][k - 1]`

#### Реализация:

В реализации мы снова отказываемся от последнего измерения и пересчитываем динамику на одномерном массиве `dist[v]`.

```c++
void findShortestPaths(int v) {
    dist[v] = 0;
    for (int i = 0; i < graph.size() - 1; i++) { // Делаем это (n - 1) раз
        for (auto t: graph.getEdges()) { // Иными словами просто перебираем все рёбра и обновляем
            if (dist[t.from] != INF) {
                dist[t.to] = std::min(dist[t.to], dist[t.from] + t.dist);
            }
        }
    }
}
```

#### Асимптотика:

$O(n * m)$

#### Отрицательные циклы

Вспомним, что алгоритм должен уметь обрабатывать отрицательные циклы.

Найдём `dp[v][n]` по тому же алгоритму (т.е. проведем ещё одну итерацию).

**Утв.** Пусть С - отриц. цикл, достижимый из s.\
Тогда найдётся хотя бы одна вершина этого цикла, что `dp[v][n] < dp[v][n - 1]`\
**Док-во:**\
Рассмотрим цикл С и веса рёбер c1..ck, Summ(c1..ck) < 0\
Поступим от противного, т.е. `dp[v][n] = dp[v][n-1]`, forall(v in C)\
Тогда `dp[v_i+1][n] <= dp[v_i][n-1] + ci`\
Складывая такие неравенства по всем рёбрам из цикла, тогда\
Summ(c1..ck) >= 0 - противоречие.

Мораль: за $O(n * m)$ можно найти хотя бы по 1 вершине на каждом отриц. цикле.
Любая вершина, достижимая из таких: `dist := -inf`.
иначе `dist[v] = dp[v][n-1]`

___

## [Sigma Omsk](https://vk.com/sigma_omsk) 2020
